package dawg

import (
	"encoding/binary"
	"fmt"
	"os"
)

// MULTIPLIER is used to store probabilities as integers in the DAWG.
const MULTIPLIER = 1000000

// ConditionalProbDistDAWG provides probability lookup for (word, tag) pairs
// using data stored in an “*.intdawg“ file generated by pymorphy2 tools.
//
// The file encodes an IntCompletionDAWG structure. For lookup purposes only
// the underlying dictionary is required, so the guide section is ignored.
type ConditionalProbDistDAWG struct {
	dict *intDict
}

// LoadConditionalProbDist loads probabilities from the specified “.intdawg“
// file. The file format is compatible with “pymorphy2“ generated
// “ConditionalProbDistDAWG“ data.
func LoadConditionalProbDist(path string) (*ConditionalProbDistDAWG, error) {
	d, err := loadIntDict(path)
	if err != nil {
		return nil, err
	}
	return &ConditionalProbDistDAWG{dict: d}, nil
}

// Prob returns the probability for a given word and tag pair. If the
// pair is not present in the dictionary, 0 is returned.
func (d *ConditionalProbDistDAWG) Prob(word, tag string) float64 {
	if d == nil || d.dict == nil {
		return 0
	}
	key := fmt.Sprintf("%s:%s", word, tag)
	if val, ok := d.dict.find([]byte(key)); ok {
		return float64(val) / MULTIPLIER
	}
	return 0
}

// intDict is a minimal reader for DAWG dictionaries storing integer values.
// It implements only the functionality required for probability lookup.
type intDict struct {
	units []uint32
}

// loadIntDict reads dictionary units from the beginning of an “.intdawg“
// file. The optional guide section present in “IntCompletionDAWG“ files is
// skipped as it is not required for lookups.
func loadIntDict(path string) (*intDict, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var size uint32
	if err := binary.Read(f, binary.LittleEndian, &size); err != nil {
		return nil, err
	}
	units := make([]uint32, size)
	if err := binary.Read(f, binary.LittleEndian, units); err != nil {
		return nil, err
	}

	// Skip the guide if present: read its size and discard the data.
	// Errors are ignored because some files may lack the guide section.
	var guideSize uint32
	if err := binary.Read(f, binary.LittleEndian, &guideSize); err == nil {
		// guide data consists of guideSize*2 bytes
		_ = binary.Read(f, binary.LittleEndian, make([]byte, guideSize*2))
	}

	return &intDict{units: units}, nil
}

// The following constants and helpers mirror logic from the “dawg“
// Python package used by pymorphy2.
const (
	precisionMask = 0xFFFFFFFF
	isLeafBit     = 1 << 31
	hasLeafBit    = 1 << 8
	extensionBit  = 1 << 9
)

func hasLeaf(base uint32) bool     { return base&hasLeafBit != 0 }
func unitValue(base uint32) uint32 { return base &^ uint32(isLeafBit) & precisionMask }
func unitLabel(base uint32) uint32 { return base & (isLeafBit | 0xFF) }
func unitOffset(base uint32) uint32 {
	return ((base >> 10) << ((base & extensionBit) >> 6)) & precisionMask
}

func (d *intDict) followChar(label byte, index uint32) (uint32, bool) {
	off := unitOffset(d.units[index])
	next := (index ^ off ^ uint32(label)) & precisionMask
	if unitLabel(d.units[next]) != uint32(label) {
		return 0, false
	}
	return next, true
}

func (d *intDict) followBytes(bs []byte, index uint32) (uint32, bool) {
	for _, b := range bs {
		var ok bool
		index, ok = d.followChar(b, index)
		if !ok {
			return 0, false
		}
	}
	return index, true
}

func (d *intDict) find(bs []byte) (uint32, bool) {
	index, ok := d.followBytes(bs, 0)
	if !ok {
		return 0, false
	}
	if !hasLeaf(d.units[index]) {
		return 0, false
	}
	off := unitOffset(d.units[index])
	valueIndex := (index ^ off) & precisionMask
	val := unitValue(d.units[valueIndex])
	return val, true
}
